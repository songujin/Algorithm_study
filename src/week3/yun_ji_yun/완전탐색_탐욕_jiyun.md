# 완전탐색
가능한 모든 경우의 수를 탐색하고 확인하는 방법. 무식하게 푼다는 의미로 **Brute-Force**라고도 한다. 

완전탐색을 이용하는 알고리즘들은 다음과 같다.
### 1. 단순 Brute-Force
반목문이나 조건문을 통해 가능한 모든 케이스를 찾는 알고리즘 기법. 최악의 경우 정말 오랜 시간이 걸리지만 100% 답을 찾아내는 확실한 방법이기도 하다.

### 2. 재귀 (Recursion)
함수 내에서 자기 자신을 다시 호출하는 기법. 재귀호출, 되부름이라고 부르기도 한다. 

### 3. 순열 (Permutation)
n개의 임의의 수열이 주어졌을 때 r개를 골라 순서를 고려해 나열한 경우의 수를 의미한다. **C++ STL에는 next_permutation() 함수가 있다**

### 4. 백트래킹 (Backtracking)
마찬가지로 가능한 모든 케이스를 찾는 기법이지만 가능성이 없는, 목표와 상관없는 불필요한 후보는 쳐내는 특징이 있다. DFS(깊이 우선 탐색)의 효율을 높이기 위해 쓰인다.

### 5. 비트마스크 (Bit Mask)
이진수 표현을 통해 정수의 집합을 아주 쉽게 표현하는 기법. shift left(<<), shift right(>>) 두개의 비트 연산으로 집합에 원소를 추가, 삭제, 변환(toggle)한다. 메모리 사용량이 적다는 장점이 있다. 

# 탐욕 알고리즘 (Greedy Algorithm)
매순간 최선의 선택을 하며 최적의 해에 도달하(려)는 알고리즘. 의도는 그렇지만 문제에 따라 최적해를 찾지 못하는 경우가 있다. 아니, 많다. 따라서 문제가 두가지 성질을 가지고 있는지 판단하는 과정이 필요하다.

두가지 성질이란 다음과 같다.
* Greedy Choice Property
    
    : 매순간 최선의 선택(지역적 최적해)으로 최선의 결과(전역적 최적해 A global optimal solution)에 도달할 수 있다.
* Optimal Substructure

    : 부분 문제의 최적해가 전체 문제의 최적해를 구성한다.

**매트로이드 구조를 띄는 문제는 그리디 알고리즘이 찰떡.**

대표적인 매트로이드 구조 문제로는 거스름돈 문제가 있다.
https://www.acmicpc.net/problem/5585