# DP 특징
    1)  Overlapping Subproblem (부분 문제가 겹친다.)
    2)  Optimal Substructure (최적 부분 구조)

1) Overlapping Subproblem
    대표적인 예로 피보나치 수열을 들 수 있다.
    
    >  Fn = Fn-1 + Fn-2
    

여기서 Fn을 큰 문제로 생각하고, 우측 항에 있는 Fn-1, Fn-2를 작은 문제로 나눈다고 생각하면 된다.


2) Optimal Substructure

문제의 정답을 작은 문제의 정답을 합하는 것으로 구할 수 있다.
위의 예에서 작은 문제로 쪼갠 우측항의 Fn-1 + Fn-2로 큰 문제인 Fn의 값을 구할 수 있다.


### Q) 그렇다면 어떻게 해야하는 가?

    DP는 Optimal Substructure를 만족하기 때문에 작은 문제로 큰 문제의 정답을 구할 수 있다.
    이때, 작은 문제의 정답을 메모해둔다. (코드에서는 배열로써 구현함)


### DP 유형

다이나믹 프로그래밍을 푸는 방식에는 두가지 방법이 있다

* Top-Down
* Bottom-Up

Top down 방식으로 문제를 푸는 방법은 다음과 같다.

* 문제를 작은 문제로 나눈다.
* 작은 문제들을 푼다.
* 작은 문제들의 답으로 전체 문제를 푼다.
* Top down 방식은 보통 재귀로 구현된다. 

----


```c++
int fibonacci(int n)
{
    if (n == 0) return 0;
    if (n == 1) return 1;

    if (dp[n] != -1) return dp[n];

    dp[n] = fibonacci(n - 1) + fibonacci(n - 2);
    return dp[n];
}
```

Bottom-Up 방식으로 문제를 푸는 방법은 다음과 같다.

* 가장 작은 문제부터 푼다.
* 문제의 크기를 점점 크게 만들어서 * 전체문제를 푼다.

```c++
int fibonacci(int n)
{
    dp[0] = 0, dp[1] = 1;
    for (int i = 2; i <= n; i++)
        dp[i] = dp[i - 1] + dp[i - 2];
}
```
두 코드의 차이라고 장단점을 말하자면, Top-down 방식은 코드의 가독성이 증가되는 장점이 있다는 점이다.

하지만 작성하기 어렵고 보통 재귀를 이용해 메모이제이션을 쓰지 않으므로 시간이 오래걸린다.

반면, Bottom-Up방식은 시간이 적게 걸리지만, 코드의 가독성이 조금 떨어진다는 단점이 있다.

----

## 분할정복과의 차이?

분할 정복은 분할했을 경우 반복적인 문제가 발생하지 않는다.

반면에 DP는 반복적인 문제가 발생하기 때문에 메모이제이션(Memoization)기법들이 필요하게 된다.

또한 이 과정에서 DP는 별도의 메모리를 소비하기 때문에 그리디 알고리즘에 비해 시간 복잡도는 크지만 문제를 풀 수 있는 스펙트럼이 넓고 근삿값이 아닌 최적의 값을 얻을 수 있다.

